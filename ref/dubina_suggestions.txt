2)код изначально был немного не корректный :)
во первых надо     int main()    вместо void main()
также происходит сравнение переменных знакового и беззнакового типа

3)изменения  (для ясности прикреплю исправленный код, старые строки просто закоменчю, рядом с новыми добавлю коментарии, возле каждого изменения дописал номера строк в прикрепленном файле для удобства):   UPD уже все написал, лучше посмотреть код т.к. я возможно не понятно все описал т.к. пока писал был очень уставший))

1. в цикле while проверка производится дважды по этому последний if в цикле можно убрать;    line:46-49

2. по хорошему предупреждать пользователя о верхней границе и проверять при вводе не превышает ли введенное число ее   line: 6-14

3. не обязательная но все же оптимизация:  вместо заполнения изначального массива решета эратосфена можно считать что нечетные числа отмечаются нулем а четные единицей, для этого нужно просто реверснуть пару if'ов(даст не большой прирост в производительности, но при бОльших верхних границах не нужно будет пробегать лишний раз по массиву)    lines:17-18, 21,23,25,26,52,56

(Для читабельности можно переименовать массив и назвать его "составные числа")

4.Для улучшения читабельности кода лучще инициализировать переменные максимально близко к месту их использования   line:27

5.в цикле while вместо постоянной проверки равенства clone_i и i лучше обнулять flip до while'а т.к. при входе в while clone_i всегда равен i   lines:37, 39-40

6. в цикле проверяется каждое число на то является ли оно палиндоромом, в целях оптимизации если проверяемое число не является простым то оно просто скипается lines: 32-35

7.также можно сделать мини оптимизацию, при выводе проходить с шагом 2, опять-же в нашей задаче не критично, но при более больших границах может быть полезно
но написать ее до проверки на палиндоромность, по причинам описанным выше т.к. в while нас интересуют только простые числа
все что нам надо - это сделать lower_border нечетным  line: 29 
и вывести 2 если оно находится в нижней границе, т.к. это простое четное число line:54

   

8. в алгоритме решета эратосфена лучше вместо j = i*2 написать j = i*i  т.к. мы уже проверили числа от 2 до i ранее, значит мы можем начинать проверять от i line:22



9. как это приняли??  оно работает несовсем корректно))
там при проверке, из while выходит когда clone_i%10 == 0 соответственно когда в числе будет ноль то число будет просчитано некорректно. Что я сделал: заменил в while вместо   clone_i % 10 != 0 на clone_i!=0 [while(clone_i)]              line:38

тоесть число 101 не выводилось хотя оно простое и является палиндоромом

